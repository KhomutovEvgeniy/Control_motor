/***************************************************************************************************
Описание: Преобразование из трехфазной с/мы в двуфазную и обратно
Разработчик: Хомутов Евгений
Заметки:
***************************************************************************************************/
#include "project_config.h"
#include "adc.h"
#include "motor_revert.h"
#include "motor_speed.h"
#include <math.h>
 
/***************************************************************************************************
Локальные дефайны
***************************************************************************************************/
#define PI 3.14159265
#define SQRT_2 1.41421356237
#define MAX_CURRENT 1000
#define MAX_VOLTAGE 1000
#define ALPHA 0.5

/***************************************************************************************************
Прототипы локальных функций
***************************************************************************************************/
int32_t lowPassFilterCurrentAlpha( int32_t newCurrentAlpha );
int32_t lowPassFilterCurrentBetta( int32_t newCurrentBetta );

int32_t transformAlphaBettaToD( float phi, int32_t projAlpha, int32_t projBetta );
int32_t transformAlphaBettaToQ( float phi, int32_t projAlpha, int32_t projBetta );

int32_t motorRevertDQtoAlfa( float phi, int32_t projD, int32_t projQ );
int32_t motorRevertDQtoBetta( float phi, int32_t projD, int32_t projQ );

/***************************************************************************************************
Локальные переменные файла
***************************************************************************************************/
static int32_t current_A;
static int32_t current_B;
static int32_t current_C;

static int32_t currentAlphaToDQ = 0; 
static int32_t currentBettaToDQ = 0;

static int32_t currentAlphaToABC = 0; 
static int32_t currentBettaToABC = 0;

static int32_t currentD;
static int32_t currentQ;

/***************************************************************************************************
Глобальные функции
***************************************************************************************************/
/***************************************************************************************************
Описание: Быстрое извлечение обратного квадратного корня 
Аргументы: Квадратный корень из чего хотим вычислить
Возврат:   Обратный квадратный корень числа
Замечания: 
***************************************************************************************************/
float fastInvSqrt(float x)
{
    float xhalf = 0.5f * x;
    uint32_t i = *(uint32_t*)&x;
    i = 0x5F3759DF - (i >> 1);
    x = *(float*)&i;
    x = x*(1.5f - xhalf*x*x);
    return x;
}

/***************************************************************************************************
Описание: Быстрое извлечение обратного квадратного корня 
Аргументы: Квадратный корень из чего хотим вычислить
Возврат:   Квадратный корень числа
Замечания: 
***************************************************************************************************/
float fastSqrt(float x) {
    if (x <= 0)
        return 0;       // if negative number throw an exception?
    int exp = 0;
    x = frexp(x, &exp); // extract binary exponent from x
    if (exp & 1) {      // we want exponent to be even
        exp--;
        x *= 2;
    }
    float y = (1+x)/2; // first approximation
    float z = 0;
    while (y != z) {    // yes, we CAN compare doubles here!
        z = y;
        y = (y + x/y) / 2;
    }
    return ldexp(y, exp/2); // multiply answer by 2^(exp/2)
}

/***************************************************************************************************
Описание: Перевод из подвижной СК dq статора в неподвижную альфа
Аргументы: Проекции тока на оси d, q
Возврат:   Проекция на ось альфа
Замечания: 
***************************************************************************************************/
int32_t motorRevertDQtoAlfa( float phi, int32_t projD, int32_t projQ )
{
    int32_t projAlpha = (-1) * projQ* sinf(2 * PI * phi / 1024) + projD * cosf(2 * PI * phi / 1024);
    
    return projAlpha;
}

/***************************************************************************************************
Описание: Перевод из подвижной СК dq статора в неподвижную бетта
Аргументы: Проекции тока на оси alfa, betta
Возврат:   Проекция на ось бетта
Замечания: 
***************************************************************************************************/
int32_t motorRevertDQtoBetta( float phi, int32_t projD, int32_t projQ )
{
    int32_t projBetta = projD * sinf(2 * PI * phi / 1024) + projQ * cosf(2 * PI * phi / 1024);
    
    return projBetta;
}

/***************************************************************************************************
Описание: Чтение с ацп и преобразование в необ скоростной диапазон 
Аргументы: Нет
Возврат:   Нет
Замечания: АЦП выдает от 0 до 4096. -2048 - т.к. смещение на 1.65В - Опорное напряжение АЦП
***************************************************************************************************/
int32_t motor_current_getCurrent( uint8_t numberOfValue )
{
    return adc_getValue( numberOfValue ) - 2048;
}

/***************************************************************************************************
Описание: Переход из трехфазной в подвижную двуфазную СК статора, перпендикулярную оси ротора
Аргументы: Проекции тока в трехфазной СК статорана
Возврат: Нет
Замечания: 
***************************************************************************************************/
void motor_revert_ABC_to_DQ( int32_t currentA, int32_t currentB, int32_t currentC, uint16_t tempPosition )
{
    // Переход из трехфазной СК статора в двуфазную альфа, бетта
    currentAlphaToDQ = currentA;
    currentBettaToDQ = (currentA + 2 * currentB) * fastInvSqrt(3);

    // ФНЧ альфа-бетта составляющих
    currentAlphaToDQ = lowPassFilterCurrentAlpha(currentAlphaToDQ);
    currentBettaToDQ = lowPassFilterCurrentBetta(currentBettaToDQ);

    // Переход из неподвижной альфа бетта в подвижную dq
    currentD = transformAlphaBettaToD(tempPosition, currentAlphaToDQ, currentBettaToDQ); 
    currentQ = transformAlphaBettaToQ(tempPosition, currentAlphaToDQ, currentBettaToDQ);
}

/***************************************************************************************************
Описание: Перевод из двуфазной в трехфазную СК статора
Аргументы: Проекции тока на оси alfa, betta
Возврат:   Нет
Замечания: 
***************************************************************************************************/
void motor_revert_DQ_to_ABC( int32_t curD, int32_t curQ, uint16_t tempPosition)
{
    // Переход из подвижной СК d'q' в неподвижную альфа, бетта
    currentAlphaToABC = motorRevertDQtoAlfa(tempPosition, curD, curQ);
    currentBettaToABC = motorRevertDQtoBetta(tempPosition, curD, curQ);
    
    // Переход из двуфазной в трехфазную СК статора
    current_A = currentAlphaToABC;
    current_B = fastSqrt(3) / 2.0 * currentBettaToABC - currentAlphaToABC / 2;
    current_C = - currentAlphaToABC / 2 - fastSqrt(3) * currentBettaToABC  / 2;
}

/***************************************************************************************************
Описание: Получение d-составляющей тока статора с обратной связи 
Аргументы: Нет
Возврат:   d-составляющая тока статора
Замечания: Нет
***************************************************************************************************/
 int32_t motor_current_getCurrentD( void )
 {
     return currentD;
 }
 
  /***************************************************************************************************
Описание: Получение q-составляющей тока статора с обратной связи 
Аргументы: Нет
Возврат:   q-составляющая тока статора
Замечания: Нет
***************************************************************************************************/
 int32_t motor_current_getCurrentQ( void )
 {
     return currentQ;
 }
 
 /***************************************************************************************************
Описание: Получение A-составляющей управляющего тока статора 
Аргументы: Нет
Возврат:   A-составляющая тока статора
Замечания: Нет
***************************************************************************************************/
 int32_t motor_current_getCurrentA( void )
 {
     return current_A;
 }
 
  /***************************************************************************************************
Описание: Получение B-составляющей управляющего тока статора 
Аргументы: Нет
Возврат:   B-составляющая тока статора
Замечания: Нет
***************************************************************************************************/
 int32_t motor_current_getCurrentB( void )
 {
     return current_B;
 }
 
  /***************************************************************************************************
Описание: Получение C-составляющей управляющего тока статора 
Аргументы: Нет
Возврат:   C-составляющая тока статора
Замечания: Нет
***************************************************************************************************/
 int32_t motor_current_getCurrentC( void )
 {
     return current_C;
 }

/***************************************************************************************************
Описание: Перевод бетта-составляющей из двуфазной СК статора во вращающуюся СК d,q статора
Аргументы: phi - угол поворота ротора в диапазоне 0 - 1024, projAlpha - альфа-составляющая тока
Возврат:   Нет
Замечания: 
***************************************************************************************************/
int32_t transformAlphaBettaToD( float position, int32_t projAlpha, int32_t projBetta )
{
    int32_t projD = projAlpha * cosf((2 * PI * position) / 1024) + projBetta * sinf((2 * PI * position) / 1024);
    
    return projD;
}

/***************************************************************************************************
Описание: Перевод альфа-составляющей из двуфазной СК статора во вращающуюся СК d,q статора
Аргументы: phi - угол поворота ротора в диапазоне 0 - 1024, projAlpha - бетта-составляющая тока
Возврат:   Нет
Замечания: 1024 - разрешение датчика угла поворота
***************************************************************************************************/
int32_t transformAlphaBettaToQ( float position, int32_t projAlpha, int32_t projBetta )
{
    int32_t projQ = (-1) * projAlpha * sinf((2 * PI * position) / 1024) + projBetta * cosf((2 * PI * position) / 1024);
    
    return projQ;
}

 /***************************************************************************************************
Описание: ФНЧ альфа-составляющей тока на подвижную СК статора альфа, бетта
Аргументы: Новое значение альфа-составляющей тока статора
Возврат:   Отфильтрованное значение
Замечания: 
***************************************************************************************************/
int32_t lowPassFilterCurrentAlpha( int32_t newCurrentAlpha )
{
    static int32_t currentAlphaFiltered = 0;

    currentAlphaFiltered = ALPHA * currentAlphaFiltered + (1 - ALPHA) * newCurrentAlpha;
    return currentAlphaFiltered;
}

 /***************************************************************************************************
Описание: ФНЧ бетта-составляющей тока на подвижную СК статора альфа, бетта
Аргументы: Новое значение бетта-составляющей тока статора
Возврат:   Отфильтрованное значение
Замечания: 
***************************************************************************************************/
int32_t lowPassFilterCurrentBetta( int32_t newCurrentBetta )
{
    static int32_t currentBettaFiltered = 0;

    currentBettaFiltered = ALPHA * currentBettaFiltered + (1 - ALPHA) * newCurrentBetta;
    return currentBettaFiltered;
}
